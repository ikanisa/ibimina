import { createClient } from "https://esm.sh/@supabase/supabase-js@2";
import { PDFDocument, rgb, StandardFonts } from "https://esm.sh/pdf-lib@1.17.1";

const corsHeaders = {
  "Access-Control-Allow-Origin": "*",
  "Access-Control-Allow-Headers": "authorization, x-client-info, apikey, content-type",
};

interface ExportRequest {
  saccoId?: string;
  district?: string;
  start?: string;
  end?: string;
  format?: "csv" | "pdf";
  locale?: "en" | "rw" | "fr";
}

const parseDate = (value: string | undefined, fallback: Date) => {
  if (!value) return fallback;
  const parsed = new Date(value);
  if (Number.isNaN(parsed.getTime())) {
    return fallback;
  }
  return parsed;
};

const formatCurrency = (amount: number) => new Intl.NumberFormat("rw-RW", { style: "currency", currency: "RWF", minimumFractionDigits: 0 }).format(amount);
const csvEscape = (value: string) => {
  if (value.includes(',') || value.includes('"') || value.includes('\n')) {
    return '"' + value.replace(/"/g, '""') + '"';
  }
  return value;
};

const toDateOnly = (value: Date) => value.toISOString().slice(0, 10);

Deno.serve(async (req) => {
  if (req.method === "OPTIONS") {
    return new Response(null, { headers: corsHeaders });
  }

  try {
    const url = new URL(req.url);
    const queryParams: ExportRequest = {
      saccoId: url.searchParams.get("saccoId") ?? undefined,
      district: url.searchParams.get("district") ?? undefined,
      start: url.searchParams.get("start") ?? undefined,
      end: url.searchParams.get("end") ?? undefined,
      format: (url.searchParams.get("format") as "csv" | "pdf" | null) ?? "pdf",
    };

    let params: ExportRequest = { ...queryParams };

    if (req.method !== "GET") {
      const contentType = req.headers.get("content-type") ?? "";
      if (contentType.includes("application/json")) {
        const body = (await req.json().catch(() => null)) as Record<string, unknown> | null;
        if (body && typeof body === "object") {
          const readString = (value: unknown) => (typeof value === "string" && value.trim() ? value.trim() : undefined);
          const readFormat = (value: unknown): "csv" | "pdf" | undefined =>
            value === "csv" || value === "pdf" ? value : undefined;
          const readLocale = (value: unknown): "en" | "rw" | "fr" | undefined =>
            value === "en" || value === "rw" || value === "fr" ? value : undefined;

          params = {
            saccoId: readString(body.saccoId) ?? params.saccoId ?? readString(body.sacco_id),
            district: readString(body.district) ?? params.district,
            start: readString(body.start) ?? readString(body.from) ?? params.start,
            end: readString(body.end) ?? readString(body.to) ?? params.end,
            format: readFormat(body.format) ?? params.format ?? "pdf",
            locale: readLocale(body.locale) ?? params.locale,
          };
        }
      }
    }

    params.format = params.format ?? "pdf";
    const locale = (params.locale ?? "en") as "en" | "rw" | "fr";

    const labels = {
      en: {
        header: (name?: string | null) => (name ? `${name} — Ibimina` : "Umurenge SACCO — Ibimina"),
        summary: "Reporting summary",
        period: "Period",
        totalPosted: "Total posted",
        dailyTotals: "Daily totals (last 14 days)",
        colIkimina: "Ikimina",
        colCode: "Code",
        colTxn: "Txn",
        colAmount: "Amount",
        colShare: "Share",
        grandTotal: "Grand total",
        generated: "Generated by SACCO+ on",
        csvHeader: "Ikimina,Code,Transactions,Amount,Share",
        csvTotal: "Total",
      },
      rw: {
        header: (name?: string | null) => (name ? `${name} — Ibimina` : "Umurenge SACCO — Ibimina"),
        summary: "Incamake ya raporo",
        period: "Igihe",
        totalPosted: "Byanditswe byose",
        dailyTotals: "Umunsi ku munsi (iminsi 14 ishize)",
        colIkimina: "Ikimina",
        colCode: "Code",
        colTxn: "Trans.",
        colAmount: "Amafaranga",
        colShare: "Igice",
        grandTotal: "Igiteranyo",
        generated: "Byakozwe na SACCO+ ku",
        csvHeader: "Ikimina,Code,Transakisi,Amafaranga,Igice",
        csvTotal: "Igiteranyo",
      },
      fr: {
        header: (name?: string | null) => (name ? `${name} — Ibimina` : "Umurenge SACCO — Ibimina"),
        summary: "Résumé du rapport",
        period: "Période",
        totalPosted: "Total validé",
        dailyTotals: "Totaux quotidiens (14 derniers jours)",
        colIkimina: "Ikimina",
        colCode: "Code",
        colTxn: "Txns",
        colAmount: "Montant",
        colShare: "Part",
        grandTotal: "Total général",
        generated: "Généré par SACCO+ le",
        csvHeader: "Ikimina,Code,Transactions,Montant,Part",
        csvTotal: "Total",
      },
    } as const;

    const numberLocale = locale === "en" ? "en-RW" : locale === "fr" ? "fr-RW" : "rw-RW";
    const formatCurrency = (amount: number) => new Intl.NumberFormat(numberLocale, { style: "currency", currency: "RWF", minimumFractionDigits: 0 }).format(amount);

    const supabaseUrl = Deno.env.get("SUPABASE_URL");
    const supabaseKey = Deno.env.get("SUPABASE_SERVICE_ROLE_KEY");

    if (!supabaseUrl || !supabaseKey) {
      throw new Error("Missing Supabase credentials");
    }

    const supabase = createClient(supabaseUrl, supabaseKey);

    const start = parseDate(params.start, new Date(Date.now() - 30 * 24 * 60 * 60 * 1000));
    const end = parseDate(params.end, new Date());

    let saccoIds: string[] | undefined;

    if (params.saccoId) {
      saccoIds = [params.saccoId];
    } else if (params.district) {
      const { data: saccoRows } = await supabase.from("saccos").select("id").eq("district", params.district);
      saccoIds = (saccoRows ?? []).map((row) => row.id as string);
    }

    let paymentsQuery = supabase
      .from("payments")
      .select("id, sacco_id, ikimina_id, amount, occurred_at, status")
      .gte("occurred_at", start.toISOString())
      .lte("occurred_at", end.toISOString());

    if (saccoIds?.length) {
      paymentsQuery = paymentsQuery.in("sacco_id", saccoIds);
    }

    const { data: payments, error: paymentsError } = await paymentsQuery;

    if (paymentsError) {
      throw paymentsError;
    }

    const { data: ibiminaRows } = await supabase.from("ibimina").select("id, name, code, sacco_id");

    const totalsByIkimina = new Map<string, { name: string; code: string; amount: number; count: number }>();
    let grandTotal = 0;
    let totalCount = 0;

    for (const payment of payments ?? []) {
      if (!payment.ikimina_id || !["POSTED", "SETTLED"].includes(payment.status)) continue;
      const match = (ibiminaRows ?? []).find((row) => row.id === payment.ikimina_id);
      if (!match) continue;
      const current = totalsByIkimina.get(payment.ikimina_id) ?? { name: match.name, code: match.code, amount: 0, count: 0 };
      current.amount += payment.amount;
      current.count += 1;
      totalsByIkimina.set(payment.ikimina_id, current);
      grandTotal += payment.amount;
      totalCount += 1;
    }

    const sortedTotals = Array.from(totalsByIkimina.values()).sort((a, b) => b.amount - a.amount);

    // Build daily totals sparkline data (last 14 days within the requested period)
    const dailyMap = new Map<string, number>();
    for (const row of (payments ?? [])) {
      if (!["POSTED", "SETTLED"].includes(row.status)) continue;
      const day = (row.occurred_at as string).slice(0, 10);
      dailyMap.set(day, (dailyMap.get(day) ?? 0) + (row.amount as number));
    }
    const dailyTotals = Array.from(dailyMap.entries())
      .sort((a, b) => a[0].localeCompare(b[0]))
      .map(([date, amount]) => ({ date, amount }));
    const lastDays = dailyTotals.slice(-14);

    if (params.format === "csv") {
      let csv = labels[locale].csvHeader + "\n";
      for (const row of sortedTotals) {
        const share = grandTotal > 0 ? Math.round((row.amount / grandTotal) * 100) : 0;
        csv += `${csvEscape(row.name)},${csvEscape(row.code)},${row.count},${row.amount},${share}%\n`;
      }
      csv += `${labels[locale].csvTotal},,${totalCount},${grandTotal},100%\n`;

      return new Response(csv, {
        headers: {
          ...corsHeaders,
          "Content-Type": "text/csv",
          "Content-Disposition": `attachment; filename="ibimina-report-${toDateOnly(start)}-to-${toDateOnly(end)}.csv"`,
        },
      });
    }

    const pdf = await PDFDocument.create();
    const page = pdf.addPage([595.28, 841.89]);
    const font = await pdf.embedFont(StandardFonts.Helvetica);
    const bold = await pdf.embedFont(StandardFonts.HelveticaBold);
    const { height } = page.getSize();

    // Branding
    let titleColor = rgb(0, 0.63, 0.87);
    let saccoName: string | null = null;
    let logoBytes: Uint8Array | null = null;
    if (params.saccoId) {
      const { data: saccoRow } = await supabase
        .from("saccos")
        .select("name, logo_url, brand_color")
        .eq("id", params.saccoId)
        .single();
      if (saccoRow) {
        saccoName = (saccoRow as { name: string | null }).name ?? null;
        const brand = (saccoRow as { brand_color?: string | null }).brand_color ?? null;
        if (brand && /^#?[0-9a-fA-F]{6}$/.test(brand)) {
          const hex = brand.startsWith('#') ? brand.slice(1) : brand;
          const r = parseInt(hex.slice(0,2),16)/255;
          const g = parseInt(hex.slice(2,4),16)/255;
          const b = parseInt(hex.slice(4,6),16)/255;
          titleColor = rgb(r,g,b);
        }
        const logoUrl = (saccoRow as { logo_url?: string | null }).logo_url ?? null;
        if (logoUrl) {
          try {
            const res = await fetch(logoUrl);
            if (res.ok) {
              const arr = new Uint8Array(await res.arrayBuffer());
              logoBytes = arr;
            }
          } catch (_) {
            // ignore logo fetch failures
          }
        }
      }
    }

    const headerTitle = labels[locale].header(saccoName);
    let cursorY = height - 72;
    if (logoBytes) {
      try {
        const isPng = logoBytes[0] === 0x89 && logoBytes[1] === 0x50; // crude check
        const img = isPng ? await pdf.embedPng(logoBytes) : await pdf.embedJpg(logoBytes);
        const scaled = img.scale(60 / img.height);
        page.drawImage(img, { x: 48, y: height - 72 - scaled.height + 8, width: scaled.width, height: scaled.height });
        page.drawText(headerTitle, { x: 48 + scaled.width + 12, y: height - 72, size: 20, font: bold, color: titleColor });
      } catch {
        page.drawText(headerTitle, { x: 48, y: height - 72, size: 20, font: bold, color: titleColor });
      }
    } else {
      page.drawText(headerTitle, { x: 48, y: height - 72, size: 20, font: bold, color: titleColor });
    }
    page.drawText(labels[locale].summary, { x: 48, y: height - 96, size: 12, font });
    page.drawText(`${labels[locale].period}: ${toDateOnly(start)} → ${toDateOnly(end)}`, { x: 48, y: height - 114, size: 10, font });
    page.drawText(`${labels[locale].totalPosted}: ${formatCurrency(grandTotal)}`, { x: 48, y: height - 132, size: 10, font });

    cursorY = height - 168;
    const rowHeight = 18;

    // Small sparkline chart (daily totals) above the table
    const chartTop = cursorY;
    if (lastDays.length > 0) {
      const chartHeight = 36;
      const chartWidth = 472;
      const chartX = 48;
      const maxVal = Math.max(...lastDays.map((d) => d.amount), 1);
      const barGap = 4;
      const barWidth = Math.max(6, Math.floor((chartWidth - (barGap * (lastDays.length - 1))) / lastDays.length));
      // Label
      page.drawText(labels[locale].dailyTotals, { x: chartX, y: cursorY, size: 10, font, color: rgb(0.35, 0.45, 0.5) });
      const baseY = cursorY - 6;
      let x = chartX;
      for (const d of lastDays) {
        const h = Math.max(2, Math.round((d.amount / maxVal) * chartHeight));
        page.drawRectangle({ x, y: baseY - h, width: barWidth, height: h, color: titleColor });
        x += barWidth + barGap;
      }
      cursorY = baseY - chartHeight - 16;
    }

    // Table header and layout helpers
    const nameX = 48;
    const codeX = 240;
    const txnX = 310;
    const amtX = 360;
    const shareX = 460;
    const nameColWidth = codeX - nameX - 8;
    const codeColWidth = txnX - codeX - 8;

    // Utility to fit text into column with ellipsis
    const fitText = (text: string, maxWidth: number, fnt: typeof font, size = 10) => {
      let t = text ?? '';
      const widthOf = (s: string) => fnt.widthOfTextAtSize(s, size);
      if (widthOf(t) <= maxWidth) return t;
      const ell = '…';
      // binary shrink
      let lo = 0;
      let hi = t.length;
      let best = '';
      while (lo <= hi) {
        const mid = Math.floor((lo + hi) / 2);
        const candidate = t.slice(0, mid) + ell;
        if (widthOf(candidate) <= maxWidth) {
          best = candidate;
          lo = mid + 1;
        } else {
          hi = mid - 1;
        }
      }
      return best || ell;
    };

    page.drawText(labels[locale].colIkimina, { x: nameX, y: cursorY, size: 11, font: bold });
    page.drawText(labels[locale].colCode, { x: codeX, y: cursorY, size: 11, font: bold });
    page.drawText(labels[locale].colTxn, { x: txnX, y: cursorY, size: 11, font: bold });
    page.drawText(labels[locale].colAmount, { x: amtX, y: cursorY, size: 11, font: bold });
    page.drawText(labels[locale].colShare, { x: shareX, y: cursorY, size: 11, font: bold });
    cursorY -= rowHeight;

    for (const row of sortedTotals) {
      if (cursorY < 72) {
        page.drawText("…", { x: 48, y: cursorY, size: 11, font });
        break;
      }
      page.drawText(fitText(row.name, nameColWidth, font), { x: nameX, y: cursorY, size: 10, font });
      page.drawText(fitText(row.code, codeColWidth, font), { x: codeX, y: cursorY, size: 10, font });
      page.drawText(String(row.count ?? 0), { x: txnX, y: cursorY, size: 10, font });
      page.drawText(formatCurrency(row.amount), { x: amtX, y: cursorY, size: 10, font });
      const share = grandTotal > 0 ? Math.round((row.amount / grandTotal) * 100) : 0;
      page.drawText(`${share}%`, { x: shareX, y: cursorY, size: 10, font });
      cursorY -= rowHeight;
    }

    page.drawRectangle({ x: 48, y: cursorY - 1, width: 472, height: 0.75, color: rgb(0.12, 0.25, 0.2) });
    cursorY -= rowHeight;
    page.drawText(`${labels[locale].grandTotal}: ${formatCurrency(grandTotal)}`, { x: 48, y: cursorY, size: 11, font: bold });
    page.drawText(`Txn: ${totalCount}`, { x: 310, y: cursorY, size: 11, font: bold });

    // Footer
    page.drawText(`${labels[locale].generated} ${new Date().toISOString().slice(0,10)}`,
      { x: 48, y: 48, size: 9, font, color: rgb(0.35,0.45,0.5) });

    const pdfBytes = await pdf.save();

    return new Response(pdfBytes, {
      headers: {
        ...corsHeaders,
        "Content-Type": "application/pdf",
        "Content-Disposition": `attachment; filename="ibimina-report-${toDateOnly(start)}-to-${toDateOnly(end)}.pdf"`,
      },
    });
  } catch (error) {
    console.error("Export report failed", error);
    const message = error instanceof Error ? error.message : "Unexpected error";
    return new Response(JSON.stringify({ error: message }), {
      headers: { ...corsHeaders, "Content-Type": "application/json" },
      status: 400,
    });
  }
});

Your new mismatch moved up to <html> itself. The dev overlay is telling you:

<html lang="en" data-theme="light" class="light"
-  style="color-scheme: light"
>


In plain terms: the server rendered style="color-scheme: light" on <html>, but the client didn’t (or vice‑versa). That’s enough to trigger React’s hydration warning.

Why this happens 99% of the time:

You’re using next-themes, which (by default) toggles data-theme/class and sets style="color-scheme: ..." on <html> so built‑in UI (form controls, scrollbars) match the theme. It modifies <html> before React hydrates, so React sees a difference unless you account for it. The library docs explicitly say to add suppressHydrationWarning on <html> because it updates that element. They also expose enableColorScheme to control the style="color-scheme: …" behavior. 
GitHub

More generally, any difference between server HTML and the initial client view causes this “attributes didn’t match” warning. 
Next.js

You’ve got two clean patterns. Pick one and stick to it.

Pattern A — Server is the source of truth (no warnings)

Let the server decide the initial theme and don’t let the client rewrite <html> attributes during hydration.

1) Layout (Server Component) — set everything deterministically

// app/layout.tsx (Server)
import { cookies } from 'next/headers';

function getInitialTheme(): 'light' | 'dark' | 'nyungwe' {
  const t = cookies().get('theme')?.value as any;
  return t === 'dark' || t === 'nyungwe' ? t : 'light';
}

function colorSchemeFor(t: string) {
  // Map your custom themes to a browser color-scheme hint
  return t === 'dark' || t === 'nyungwe' ? 'dark' : 'light';
}

export default function RootLayout({ children }: { children: React.ReactNode }) {
  const theme = getInitialTheme();
  const colorScheme = colorSchemeFor(theme);

  return (
    <html
      lang="en"
      suppressHydrationWarning
      // Choose ONE attribute strategy: class OR data-*. Don’t set both.
      className={theme}         // if using Tailwind's `darkMode: 'class'`
      // data-theme={theme}     // if using selector-based dark mode
      style={{ colorScheme }}   // matches SSR and client
    >
      <body className={/* your root classes that depend on theme */ ''}>
        {/* Pass the same theme to your providers */}
        <AppProviders forcedTheme={theme}>{children}</AppProviders>
      </body>
    </html>
  );
}


2) ThemeProvider (Client) — don’t fight <html>

// app/app-providers.tsx (Client)
'use client';

import { ThemeProvider } from 'next-themes';

export function AppProviders({
  children,
  forcedTheme,
  nonce,
}: {
  children: React.ReactNode;
  forcedTheme: 'light' | 'dark' | 'nyungwe';
  nonce?: string;
}) {
  return (
    <ThemeProvider
      attribute="class"        // match the layout (or 'data-theme' if you used that)
      enableSystem={false}     // initial theme comes from the server
      enableColorScheme={false} // IMPORTANT: let the server set color-scheme
      forcedTheme={forcedTheme}
      nonce={nonce}
    >
      {children}
    </ThemeProvider>
  );
}


Why this fixes your exact diff: the same style={{ colorScheme: 'light'|'dark' }} is present on both server and client, and next-themes is told not to add/remove the color-scheme style on its own. Hydration can relax.

Pattern B — Client owns <html> (allow it, but silence the warning)

If you want next-themes to manage <html> (fastest path, minimal code):

Do not set className, data-theme, or style on <html> in your server layout (let the client do it).

Add suppressHydrationWarning to <html> so React ignores the initial attribute mismatch caused by the pre‑hydrate theme script.

Keep enableColorScheme={true} (the default) so next-themes injects style="color-scheme: …" itself.

// app/layout.tsx
export default function RootLayout({ children }: { children: React.ReactNode }) {
  return (
    <html lang="en" suppressHydrationWarning>
      <body>
        <AppProviders /* no forced style/class here */>
          {children}
        </AppProviders>
      </body>
    </html>
  );
}

// app/app-providers.tsx (Client)
'use client';
import { ThemeProvider } from 'next-themes';

export function AppProviders({ children, nonce }: any) {
  return (
    <ThemeProvider
      attribute="class"       // or 'data-theme' — PICK ONE and configure Tailwind accordingly
      enableSystem={true}     // or false – your choice
      enableColorScheme={true} // default; will set style="color-scheme: …" on <html>
      nonce={nonce}
    >
      {children}
    </ThemeProvider>
  );
}


next-themes explicitly recommends the suppressHydrationWarning on <html> because it updates that element pre-hydration. 
GitHub

Very likely footgun in your current code

You’ve got:

<html
  lang="en"
  data-theme="light"
  className="light"
  // (server-only) style={{ colorScheme: 'light' }}
>


…and a ThemeProvider that probably uses attribute="class" or defaults to data-theme. That means:

The server is setting both class and data-theme, but the client will only mutate one of them (depending on attribute). The other can drift and cause warnings.

If enableColorScheme is true on the client and you also set style={{ colorScheme }} on the server, they must exactly match or you’ll get the diff you’re seeing. Easiest: either let the client own it (Pattern B) or turn it off on the client and own it on the server (Pattern A). 
GitHub

Tailwind alignment (pick one mode)

If you use class-based theming: darkMode: 'class' (older Tailwind) or just keep default and use class. Then set attribute="class" in ThemeProvider and only set className on <html>.

If you use a selector (recommended with multiple themes): darkMode: ['selector', '[data-theme="dark"]'] (Tailwind ≥ 3.4.1) and set attribute="data-theme" in ThemeProvider. Only set data-theme on <html>. The next‑themes docs have both patterns. 
GitHub

References (for the curious)

Next.js hydration mismatch message and causes (React/Next docs). 
Next.js

next-themes behavior on <html>, suppressHydrationWarning, and enableColorScheme. 
GitHub

Quick checklist to apply now

Choose Pattern A (server owns <html>) or Pattern B (client owns <html>).

Don’t set both class and data-theme on <html>; pick one and configure ThemeProvider.attribute to match. 
GitHub

If server sets style={{ colorScheme }}, set enableColorScheme={false} on ThemeProvider. If client sets it, don’t set it on the server and add suppressHydrationWarning. 
GitHub

Restart dev and clear .next/ if the overlay still says “(stale)” after these changes.
You're getting a classic hydration mismatch—and your own diff shows the culprit.

SSR: className="... bg-white text-gray-900"
Client: className="... bg-nyungwe text-neutral-0"

That means the server rendered “light”, but the client switched to a custom theme (“nyungwe”) before/while hydrating. React won’t “patch this up”; once the DOM and the virtual tree disagree at hydration time, you’re in undefined-behavior land (flickers, lost event handlers, or re-rendered subtrees). Next.js surfaces exactly this scenario in its hydration docs. 
Next.js

Below is a surgical plan to fix it, plus a few deeper cleanups to keep the error from coming back.

Fix it fast: make the server and client agree on theme

Goal: ensure the server decides the same initial theme the client will use.

1) Read the theme on the server and render it into the HTML

In the App Router, do this in your app/layout.tsx (Server Component). Read the theme from a cookie or user profile, then stamp a stable class/attribute onto <html> or <body>.

// app/layout.tsx (Server Component)
import type { ReactNode } from 'react';
import { cookies } from 'next/headers'; // Marks route dynamic automatically
import './globals.css';

function getInitialTheme() {
  const t = cookies().get('theme')?.value; // "nyungwe" | "light" | undefined
  return t === 'nyungwe' ? 'nyungwe' : 'light';
}

export default function RootLayout({ children }: { children: ReactNode }) {
  const theme = getInitialTheme();

  // One clear place that controls the root classes:
  const rootClass =
    theme === 'nyungwe'
      ? 'relative flex min-h-screen flex-col bg-nyungwe text-neutral-0'
      : 'relative flex min-h-screen flex-col bg-white text-gray-900';

  return (
    <html lang="en" data-theme={theme}>
      <body className={rootClass}>{children}</body>
    </html>
  );
}


Notes:

Using cookies() here opts this route into dynamic rendering so the cookie value actually affects SSR. This is the correct signal with Next 16’s rendering model. 
Next.js
+2
Vercel
+2

If you’re using Cache Components / Partial Prerendering in v16, remember that request-specific data like cookies isn’t available inside static cacheable parts; read it in a dynamic boundary (or wrap a dynamic region with <Suspense> so the rest can stay cached). 
Next.js

2) Change the theme via a server action that sets the cookie
// app/actions/set-theme.ts
'use server';

import { cookies } from 'next/headers';

export async function setTheme(theme: 'light' | 'nyungwe') {
  cookies().set('theme', theme, {
    path: '/',
    sameSite: 'lax',
    // not httpOnly so the client can read it if needed, but prefer server to be source of truth
  });
}

// components/theme-toggle.tsx (Client Component)
'use client';

import { useTransition } from 'react';
import { setTheme } from '@/app/actions/set-theme';

export function ThemeToggle({ current }: { current: 'light' | 'nyungwe' }) {
  const [pending, start] = useTransition();

  return (
    <button
      disabled={pending}
      onClick={() => start(() => setTheme(current === 'light' ? 'nyungwe' : 'light'))}
    >
      {pending ? 'Switching…' : 'Toggle theme'}
    </button>
  );
}


This ensures the next SSR (navigation or refresh) and the client have the same starting point.

3) If you use next-themes, render safely

next-themes warns that reading theme on the server is hydration-unsafe unless you gate rendering until after mount. If you do use it, either force the initial theme from the server or delay the parts that depend on theme until mounted. 
GitHub

Minimal safe pattern:

// app/providers.tsx
'use client';
import { ThemeProvider } from 'next-themes';

export function Providers({ children, forcedTheme }: { children: React.ReactNode; forcedTheme?: string }) {
  return (
    <ThemeProvider
      attribute="class"
      defaultTheme="light"
      forcedTheme={forcedTheme /* ← makes SSR and client match */}
      enableSystem={false}
      disableTransitionOnChange
    >
      {children}
    </ThemeProvider>
  );
}


On the server (layout), pass forcedTheme={themeFromCookies}. This avoids the “SSR light / client dark” mismatch that your diff shows. 
GitHub

Escape hatch: You can use suppressHydrationWarning on the exact element whose attributes must differ (e.g., timestamps), but treat it as a last resort; it silences warnings and can prevent proper re-rendering. Better to fix the root cause. 
react.dev
+1

Double-check common hydration booby traps

The Next.js hydration message lists usual suspects; grep for them and move them out of render or make them stable:

Environment branches in render: if (typeof window !== 'undefined')
Move this into a useEffect, or dynamically import the client-only component with ssr: false (sparingly). 
Next.js

Unstable values: Date.now(), Math.random(), new Date().toLocaleString() in render.
Replace with stable props from the server, or compute after mount. For IDs, prefer useId which is SSR/CSR-consistent. 
react.dev

Invalid tag nesting / DOM shape differences: e.g., <p><div/></p> or CMS HTML that gets cleaned on the client. Fix the markup. 
Stack Overflow

Quick search script you can run at the repo root:

rg -n "typeof window|Date\\.now\\(|Math\\.random\\(|new Date\\(|toLocale(Date|String)\\(|suppressHydrationWarning" --glob '!node_modules'

About the (stale) dev overlay

When the overlay says “Next.js 16.0.0 (stale)”, it usually means your client has loaded an older dev build while Turbopack has already produced a newer one. A hard refresh typically clears it; after bigger config changes, delete .next/ and restart the dev server to ensure you’re not diffing against cached output. (No special sauce needed—just classic dev server cache weirdness.)

That other error: [admin/overview] failed to render overview: [object Object]

That’s a logging problem hiding the real exception. You’re logging an object without serializing it (probably across an RSC boundary), so you just see the default stringifier.

Instrument it so you see the message and stack, and let the App Router error boundary do its job:

// app/admin/overview/error.tsx
'use client';
import { useEffect } from 'react';

export default function Error({
  error,
  reset,
}: { error: Error & { digest?: string }; reset: () => void }) {
  useEffect(() => {
    console.error('[admin/overview] error digest:', error?.digest, error);
  }, [error]);

  return (
    <div className="space-y-2">
      <p>Something went sideways on the overview page.</p>
      <button onClick={reset}>Try again</button>
    </div>
  );
}


…and upgrade your server-side logging to preserve stack traces:

try {
  // server work
} catch (err) {
  const e = err instanceof Error ? { msg: err.message, stack: err.stack, name: err.name } : err;
  console.error('[admin/overview] failed to render overview:', e);
  throw err; // Let the route segment error boundary render
}


If you access cookies/headers from inside a Cache Component (Next 16), that’s also a likely cause—move that access into a dynamic boundary or wrap it in <Suspense> so it streams separately. The docs call out that request-specific info isn’t available during static prerendering. 
Next.js

A short mental model (why this happens)

Hydration is React matching server HTML to the initial client render. If they differ, React complains and won’t auto-heal. 
react.dev

In Next 16, Cache Components / PPR try to keep as much as possible static, and only punch holes for dynamic bits. If a “supposedly static” area derives theme from request-time state (cookie/profile) on the client only, you’ll get exactly your diff. Make the server the source of truth for the initial render, and the mismatch disappears. 
Next.js
+1

Checklist you can commit today

Compute initialTheme on the server (cookies or profile) and render it into <html>/<body>. 
Next.js

Change the theme via a server action that sets the cookie; don’t let the first client render surprise the DOM.

If using next-themes, pass forcedTheme from the server or delay the theme-dependent UI until mounted. 
GitHub

PPR/Cache Components: keep request-specific bits inside a dynamic/Suspense boundary. 
Next.js

Remove unstable values in render (use useId for deterministic IDs; move Date.now() to effects or server). 
react.dev

Clean dev cache after config changes: stop dev server, rm -rf .next, restart.

Do that, and the “bg-white ↔ bg-nyungwe” split-brain goes away—and so will the hydration error.